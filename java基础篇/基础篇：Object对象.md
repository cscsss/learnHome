<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"><h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">1 Object的内存结构和指针压缩了解一下</span><span class="suffix"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733c9947d613d5c?w=1112&amp;h=612&amp;f=png&amp;s=73251" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;">//hotspot的oop.hpp文件中class oopDesc
<span/>class oopDesc {
<span/>  friend class VMStructs;
<span/>  private:
<span/>  volatile markOop  _mark; //对象头部分
<span/>  union _metadata {  // klassOop 类元数据指针
<span/>    Klass*      _klass;   
<span/>    narrowKlass _compressed_klass;
<span/>  } _metadata;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Object的实例数据内存使用三部分组成的，<strong style="font-weight: bold; color: black;">对象头</strong>，<strong style="font-weight: bold; color: black;">实际数据区域</strong>、<strong style="font-weight: bold; color: black;">内存对齐区</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对象头布局如下：主要和锁，hashcode，垃圾回收有关；由于锁机制的内容篇幅过长，这里就不多解释了；和锁相关的markWord（markOop）内存布局如下
<img src="https://user-gold-cdn.xitu.io/2020/7/11/1733c7691fcdd34c?w=879&amp;h=607&amp;f=png&amp;s=56535" alt style="display: block; margin: 0 auto; max-width: 100%;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">内存对齐</strong>区是什么? HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">内存对齐</strong>好处
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">有利于内存的管理</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">更快的CPU读取，CPU从内存获取数据，并不是一个个字节的读取，而是按CPU能处理的长度获取，如32位机，是4个字节的内存块；当只需其中两个字节时，则由内存处理器处理挑选。如果需要三个字节分布在两个不同内存块（四字节的内存块），则需要读取内存两次（如果是存在同一内存块只需一次读取）。而当对象按一定的规则合理对齐时，CPU就可以最少地请求内存，加快CPU的执行速度</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">指针压缩</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在上图可以看到，在64位jvm里Object的MarkWord会比32位的大一倍；其实klassOop也扩大一倍占了64位（数组长度部分则是固定四字节）。指针的宽度增大，但是对于堆内存小于4G的，好像也用不到64位的指针。这可以优化吗？答案是就是指针压缩</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">指针压缩的原理是利用jvm植入压缩指令，进行编码、解码</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">哪些信息会被压缩
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">会被压缩对象：类属性、对象头信息、对象引用类型、对象数组类型</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不被压缩对象：本地变量，堆栈元素，入参，返回值，NULL这些指针</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">指针压缩开启，klassOop大小可以由64bit变成32bit；对象的大小可以看看下面的具体对比:<a href="https://www.freesion.com/article/4677944161/" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">JVM - 剖析JAVA对象头OBJECT HEADER之指针压缩</a></section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">public static void main(String[] args){
<span/>    Object a = new Object(); // 16B   关闭压缩还是16B，需要是8B倍数;12B+填充的4B
<span/>    int[] arr = new int[10]; // 16B   关闭压缩则是24B
<span/>}
<span/>
<span/>public class ObjectNum {
<span/>    //8B mark word
<span/>    //4B Klass Pointer   如果关闭压缩则占用8B
<span/>    //-XX:-UseCompressedClassPointers或-XX:-UseCompressedOops，
<span/>    int id;        //4B
<span/>    String name;   //4B  如果关闭压缩则占用8B
<span/>    byte b;        //1B  实际内存可能会填充到4B
<span/>    Object o;      //4B  如果关闭压缩则占用8B
<span/>}
<span/></code></pre>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">为什么开启指针压缩时，堆内存最好不要超过32G，指针使用32个bit，为什么最大可使用内存不是4G而是32G
<br>jvm要求对象起始位置对齐8字节的倍数，可以利用这点提升选址范围，理论上可以提升到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">2^11 * 4G</code>。不过jvm只是将指针左移三位，因此<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">2^3 * 4G = 32G</code>。如果<strong style="font-weight: bold; color: black;">大于32G</strong>,指针压缩会失效。如果GC堆大小在 <strong style="font-weight: bold; color: black;">4G以下</strong>，直接砍掉高32位，避免了编码解码过程</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">启用指针压缩<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">-XX:+UseCompressedOops</code>(<strong style="font-weight: bold; color: black;">默认开启</strong>)，禁止指针压缩:<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">-XX:-UseCompressedOops</code></section></li></ul>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">2 Object的几种基本方法</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本地方法
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">private static native void registerNatives()</code>  将Object定义的本地方法和java程序链接起来。<a href="https://user-gold-cdn.xitu.io/2020/7/11/1733bf3794fbe8f3" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">Object类中的registerNatives</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">public final native Class&lt;?&gt; getClass()</code> 获取java的Class元数据</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">public native int hashCode()</code>  获取对象的哈希Code</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">protected native Object clone() throws CloneNotSupportedException</code> 获得对象的克隆对象，浅复制</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">public final native void notify()</code>  唤醒等待对象锁waitSet队列中的一个线程</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">public final native void notifyAll()</code> 类似notify(),唤醒等待对象锁waitSet队列中的全部线程</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">public final native void wait(long timeout)</code> 释放对象锁,进入对象锁的waitSet队列</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">普通方法<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">public String <span class="hljs-function" style="line-height: 26px;"><span class="hljs-title" style="color: #1c00cf; line-height: 26px;">toString</span></span>() { <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span> getClass().getName() + <span class="hljs-string" style="color: #c41a16; line-height: 26px;">"@"</span> + Integer.toHexString(hashCode());}
<span/>public boolean equals(Object obj) { <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span> (this == obj);}
<span/>public final void <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">wait</span>(long timeout, int nanos) throws InterruptedException;
<span/>//都是基于native void <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">wait</span>(long timeout)实现的
<span/>public final void <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">wait</span>() throws InterruptedException;
<span/><span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">wait</span>(long timeout, int nanos)、<span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">wait</span>() 
<span/>//jvm回收对象前，会特意调用此方法 
<span/>protected void finalize() throws Throwable; 
<span/></code></pre>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">3 == 、 equals、Comparable.compareTo、Comparator.compara 四种比较方法</span><span class="suffix"></span></h1>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">如不指定排序顺序，java里的默认排序顺序是升序的，从小到大</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">==， (A)对于基本类型之间的比较是值 (B)基本类型和封装类型比较也是值比较 (C)对于引用类型之间的比较则是内存地址</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">equals(Object o)， 在Object基本方法里可以看到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">public boolean equals(Object obj) { return (this == obj);}</code> 是使用 == 去比较的。equals方法的好处是我们可以重写该方法</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Comparable.compareTo 是接口Comparable里的抽象方法；如果对象实现该接口，可使用Collections.sort(List&lt; T&gt; col)进行排序。接下来看看源码怎么实现的<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">Collections.java
<span/>//Collections.sort(List&lt;T&gt; list),调用的是List的sort方法
<span/>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) {
<span/>    list.sort(null);
<span/>}
<span/></code></pre>
List的sort 则调用了Arrays.sort<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">List.java
<span/>default void sort(Comparator&lt;? super E&gt; c) {
<span/>    Object[] a = this.toArray();
<span/>    Arrays.sort(a, (Comparator) c);
<span/>    ListIterator&lt;E&gt; i = this.listIterator();
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">for</span> (Object e : a) {
<span/>        i.next();
<span/>        i.set((E) e);
<span/>    }
<span/>}
<span/></code></pre>
如果Comparator c 为null,则是调用 Arrays.sort(Object[] a) ；最终调用LegacyMergeSort(归并排序)方法处理<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">Arrays.java
<span/>public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (c == null) {
<span/>        sort(a);
<span/>    } <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">else</span> {
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (LegacyMergeSort.userRequested)
<span/>            legacyMergeSort(a, c);
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">else</span>
<span/>            TimSort.sort(a, 0, a.length, c, null, 0, 0);
<span/>    }
<span/>}
<span/></code></pre>
LegacyMergeSort方法里的一段代码；最终底层是使用<strong style="font-weight: bold; color: black;">归并排序</strong>和compareTo来排序<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">Arrays.java
<span/>......
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (length &lt; INSERTIONSORT_THRESHOLD) {
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">for</span> (int i=low; i&lt;high; i++)
<span/>            <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">for</span> (int j=i; j&gt;low &amp;&amp;
<span/>                     ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)
<span/>                swap(dest, j, j-1);
<span/>        <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span>;
<span/>    }
<span/></code></pre>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Comparator也是一个接口，不过提供了更丰富的操作，需要实现<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">int compare(T o1, T o2)</code>方法
<br>Comparator提供了常用的几个静态方法thenComparing、reversed、reverseOrder（操作对象需要实现Comparator或者Comparable）；可配合List.sort、Stream.sorted、Collections.sort使用。<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">@Data
<span/>@AllArgsConstructor
<span/>static class Pair implements Comparator&lt;Pair&gt;, Comparable&lt;Pair&gt; {
<span/>    Integer one;
<span/>    Integer two;
<span/>    @Override
<span/>    public String <span class="hljs-function" style="line-height: 26px;"><span class="hljs-title" style="color: #1c00cf; line-height: 26px;">toString</span></span>() { <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span> one + <span class="hljs-string" style="color: #c41a16; line-height: 26px;">"-"</span> + two; }
<span/>    @Override
<span/>    public int compareTo(Pair o) { <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span> one.compareTo(o.one);  }
<span/>    @Override
<span/>    public int compare(Pair o1, Pair o2) {<span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span> o1.compareTo(o2);}
<span/>}
<span/>public static void main(String[] args) {
<span/>    List&lt;Pair&gt; col = Arrays.asList( new Pair(4, 6), new Pair(4, 2),new Pair(1, 3));
<span/>    col.sort(Comparator.reverseOrder());
<span/>    System.out.println(<span class="hljs-string" style="color: #c41a16; line-height: 26px;">"----------------"</span>);
<span/>    col.stream().sorted(Comparator.comparing(Pair::getOne).thenComparing(Pair::getTwo))
<span/>            .forEach(item -&gt;  System.out.println(item.toString()) );
<span/>}
<span/></code></pre>
Collections.sort默认是升序排序的，可以看到reverseOrder将顺序反过来了； 用了thenComparing的col则是先判断Pair::getOne的大小，如果相等则判断Pair::getTwo大小来排序<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">result:
<span/>4-6
<span/>4-2
<span/>1-3
<span/>----------------
<span/>1-3
<span/>4-2
<span/>4-6
<span/></code></pre>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">4 方法的重写和重载</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">方法的<strong style="font-weight: bold; color: black;">重写</strong>是指子类定义和父类方法的<strong style="font-weight: bold; color: black;">名称、参数及顺序一致</strong>的方法；需要注意的是，子类重写方法<strong style="font-weight: bold; color: black;">修饰符</strong>不能更加严格，就是说父类方法的修饰符是protected，子类不能使用private修饰而可用public,抛出的<strong style="font-weight: bold; color: black;">异常</strong>也不能比父类方法定义的更广</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">方法的<strong style="font-weight: bold; color: black;">重载</strong>则是同一个类中定义和已有方法的<strong style="font-weight: bold; color: black;">名称一致而参数或者参数顺序不一致</strong>的方法，(返回值不能决定方法的重载)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">重载的方法在编译时就可确定(编译时多态)，而重写的方法需要在运行时确定(运行时多态，我们常说的多态)
<br>多态的三个必要条件 1、有继承关系 2、子类重写父类方法 3、父类引用指向子类对象</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">5 构造方法是否可被重写</span><span class="suffix"></span></h1>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">构造方法是每一个类独有的，并不能被子类继承，因为构造方法没有返回值，子类定义不了和父类的构造方法一样的方法。但是在同一个类中，构造方法可以重载</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;">public class TestEquals {
<span/>    int i;
<span/>    public <span class="hljs-function" style="line-height: 26px;"><span class="hljs-title" style="color: #1c00cf; line-height: 26px;">TestEquals</span></span>() {   i = 0; }
<span/>    //构造方法重载
<span/>    public TestEquals(int i) {   this.i = i } 
<span/>}
<span/></code></pre>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">6 Object的equals和hashCode</span><span class="suffix"></span></h1>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">equals是用来比较两个对象是否相等的，可以重写该方法来实现自定义的比较方法；而hashCode则是用来获取对象的哈希值，也可以重写该方法。当对象存储在Map时,是首先利用Object.hashCode判断是否映射在同一位置，若在同一映射位，则再使用equals比较两个对象是否相同。</p>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">7 equals一样，hashCode不一样有什么问题？</span><span class="suffix"></span></h1>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">如果重写equals导致对象比较相同而hashCode不一样，是违反JDK规范的；而且当用HashMap存储时，可能会存在多个我们自定义认为相同的对象，这样会为我们代码逻辑埋下坑。</p>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">8 Object.wait和Thread.sheep</span><span class="suffix"></span></h1>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">Object.wait是需要在synchronized修饰的代码内使用，会让出CPU,并放弃对对象锁的持有状态。而Thread.sleep则简单的挂起，让出CPU,没有释放任何锁资源</p>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">9 finalize方法的使用</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果对象重写了finalize方法，jvm会把当前对象注册到FinalizerThread的ReferenceQueue队列中。对象没有其他强引用被当垃圾回收时，jvm会判断ReferenceQueue存在该对象，则暂时不回收。之后FinalizerThread（独立于垃圾回收线程）从ReferenceQueue取出该对象，执行自定义的finalize方法，结束之后并从队列移除该对象，以便被下次垃圾回收</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">finalize会造成对象延后回收，可能导致内存溢出，慎用</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">finally和finalize区别
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">finally是java关键字，用来处理异常的，和try搭配使用</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果在finally之前return，finally的代码块会执行吗？                       <br>try内的continue,break,return都不能绕过finally代码块的执行，try结束之后finally是一定会被执行的</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">相似的关键字final
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">final修饰类，该类不能被继承；修饰方法，方法不能被重写；修饰变量，变量不能指向新的值；修饰数组，数组引用不能指向新数组，但是数组元素可以更改</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果对象被final修饰，变量有哪几种声明赋值方式？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">fianl修饰普通变量：1、定义时声明 2、类内代码块声明 3、构造器声明</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">fianl修饰静态变量：1、定义时声明 2、类内静态代码块声明</section></li></ul>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">10 创建对象有哪几种方法</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">1、使用new创建</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">2、运用反射获取Class,在newInstance()</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">3、调用对象的clone()方法</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">4、通过反序列化得到，如:<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">ObjectInputStream.readObject()</code></section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">11 猜猜创建对象的数量</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">String one = new String("Hello");</code>
<br> <strong style="font-weight: bold; color: black;">两个对象</strong>和一个<strong style="font-weight: bold; color: black;">栈变量</strong>：一个栈变量one和一个new String()实例对象、一个"hello"字符串对象</section></li></ul>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733ce19a8dc0e7d?w=581&amp;h=342&amp;f=png&amp;s=24117" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">题外话:string.intern();intern先判断常量池是否存相同字符串,存在则返回该引用；否则在常量池中记录堆中首次出现该字符串的引用，并返回该引用。
<br>如果是先执行 <code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">String s = "hello" ;</code>相当于执行了intern();先在常量池创建"hello",并且将引用A存入常量池，返回给s。此时String("hello").intern()会返回常量池的引用A返回</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;">    String one = <span class="hljs-string" style="color: #c41a16; line-height: 26px;">"hello"</span>;
<span/>    String two = new String(<span class="hljs-string" style="color: #c41a16; line-height: 26px;">"hello"</span>);
<span/>    String three = one.intern();
<span/>    System.out.println(two == one);
<span/>    System.out.println(three == one);
<span/>    
<span/>    result:
<span/>    <span class="hljs-literal" style="color: #aa0d91; line-height: 26px;">false</span>  // one虽然不等于two;但是它们具体的char[] value 还是指向同一块内存的
<span/>    <span class="hljs-literal" style="color: #aa0d91; line-height: 26px;">true</span>  // one 和 three 引用相同
<span/></code></pre>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/11/1733cdcdd7000538?w=965&amp;h=341&amp;f=png&amp;s=28160" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">12 对象拷贝问题</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">引用对象的<strong style="font-weight: bold; color: black;">赋值复制</strong>是复制的引用对象，<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">A a = new A(); A b = a;</code>此时a和b指向同一块内存的对象</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用Object.clone()方法，如果字段是值类型(基本类型)则是复制该值，如果是引用类型则复制对象的引用而并非对象<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">@Getter
<span/>static class A implements Cloneable{
<span/>    private B b; 
<span/>    private int index;
<span/>    public <span class="hljs-function" style="line-height: 26px;"><span class="hljs-title" style="color: #1c00cf; line-height: 26px;">A</span></span>(){
<span/>        b = new B(); index = 1000;
<span/>    }
<span/>    public A <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">clone</span>()throws CloneNotSupportedException{  <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span> (A)super.clone(); }
<span/>}
<span/>static class B{
<span/>}
<span/>public static void main(String[] args) throws Exception{
<span/>    A a = new A();
<span/>    A copyA = a.clone();
<span/>    System.out.println( a.getIndex() == copyA.getIndex() );
<span/>    System.out.println( a.getB() == copyA.getB() );
<span/>}
<span/></code></pre>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">//返回结果都是<span class="hljs-literal" style="color: #aa0d91; line-height: 26px;">true</span>,引用类型只是复制了引用值
<span/><span class="hljs-literal" style="color: #aa0d91; line-height: 26px;">true</span>
<span/><span class="hljs-literal" style="color: #aa0d91; line-height: 26px;">true</span>
<span/></code></pre>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">深复制：重写clone方法时使用序列化复制,(注意需要实现Cloneable，Serializable)<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: block; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;">public A <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">clone</span>() throws CloneNotSupportedException {
<span/>        try {
<span/>            ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
<span/>            ObjectOutputStream out = new ObjectOutputStream(byteOut);
<span/>            out.writeObject(this);
<span/>            ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());
<span/>            ObjectInputStream inputStream = new ObjectInputStream(byteIn);
<span/>            <span class="hljs-built_in" style="color: #5c2699; line-height: 26px;">return</span> (A) inputStream.readObject();
<span/>        } catch (Exception e) {
<span/>            e.printStackTrace();
<span/>            throw new CloneNotSupportedException(e.getLocalizedMessage());
<span/>        }
<span/>    }
<span/></code></pre>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">关注公众号，一起交流</span><span class="suffix"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367b94da0e9fd2?w=1013&amp;h=451&amp;f=png&amp;s=212256" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">参考文章</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://user-gold-cdn.xitu.io/2020/7/11/1733bf3794fbe8f3" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">Object类中的registerNatives</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://baijiahao.baidu.com/s?id=1655232869611610920" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">在java中为什么不推荐使用finalize</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://www.jianshu.com/p/194b745884a5" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">一个Java对象到底占用多大内存？</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://www.cnblogs.com/ulysses-you/p/10060463.html#_label5" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">java对象在内存的大小</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://blog.csdn.net/G_METHOD/article/details/79535178" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">为什么需要内存对齐以及对齐规则的简单分析</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://www.freesion.com/article/4677944161/" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">JVM - 剖析JAVA对象头OBJECT HEADER之指针压缩</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><a href="https://blog.csdn.net/tyyking/article/details/82496901" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: #009688; border-bottom: 1px solid #009688;">几张图轻松理解String.intern()</a></section></li></ul>
</section>