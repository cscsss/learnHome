<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df9b17a2f5ec4604936b4e36536d6550~tplv-k3u1fbpfcp-zoom-1.image" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">1 JVM的内存区域布局</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">java代码的执行步骤有三点
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">java源码文件-&gt;编译器-&gt;字节码文件</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">字节码文件-&gt;JVM-&gt;机器码</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">机器码-&gt;系统CPU执行</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JVM执行的字节码需要用类加载来载入；字节码文件可以来自本地文件，可以在网络上获取，也可以实时生成。就是说你可以跳过写java代码阶段，直接生成字节码交由JVM执行</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">其中Java虚拟机栈、程序计数器、Heap、本地方法栈、Metaspace属于JVM运行时的内存；按<strong style="font-weight: bold; color: black;">是否线程共享</strong>则可以分两类
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4307309846df4714acf4e0ef3002a8a5~tplv-k3u1fbpfcp-zoom-1.image" alt style="display: block; margin: 0 auto; max-width: 100%;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JAVA堆和MetasSpace元空间属于线程共享的；虚拟机栈和本地方法栈、程序计数器是线程私有的</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">2 JVM五大数据区域介绍</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">2.1 程序计数器（Progarm Counter Register)</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一块较小的内存空间, 是当前线程所执行的字节码的行号指示器。线程有一个独属的程序计数器，字节码解析工作时需要程序计数器来选取下一指令，分支、循环、跳转等依赖它</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">正在执行java方法线程的计数器记录的是虚拟机字节码指令的地址；如果还是Native方法，则为空</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">程序计数器内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError错误的区域</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">2.2 虚拟机栈(Virtual Machine Stack)</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/307a1013fb4248a9b899f6700057fe99~tplv-k3u1fbpfcp-zoom-1.image" alt style="display: block; margin: 0 auto; max-width: 100%;">
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派(Dispatch Exception)。栈帧随着方法调用而创建，随着方法结束而销毁(无论方法是正常完成还是异常完成)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如果线程请求的栈深度大于虚拟机允许深度，则抛出StackOverflowError；扩展时无法申请到足够内存，则抛出OutOfMemeryError</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">2.3 本地方法栈(Native Method Stack)</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">本地方法栈和虚拟机栈作用类似，区别是虚拟机栈为执行Java方法服务，而本地方法栈则为Native方法服务。(HopShot的实现 直接把本地方法栈和虚拟机栈合二为一）</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">上述3类区域，生命周期与Thread相同，即：线程创建时，相应的内存区创建，线程销毁时，释放相应内存</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">2.4 堆(Heap)</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">线程共享的一块内存区域，几乎所有的对象实例在这里分配内存，也是垃圾收集器进行垃圾收集的最重要的内存区域。因此很多时候也叫GC堆</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">线程私有的分配缓存区(Thread Local Alloaction Buffer)也是在堆划分出来的</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JDK8的版本，因使用元空间代替永久代，字符串常量池和类的静态变量也放入java堆中
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/795e0a9952f34149af26deb3c9610f5c~tplv-k3u1fbpfcp-zoom-1.image" alt style="display: block; margin: 0 auto; max-width: 100%;"></section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">2.5 元空间(MetaSpace)</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">主要存储类的元数据，比如类的各种描述信息，类名、方法、字段、访问限制等，既编译器编译后的代码等数据</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">运行时常量池</strong>：Class文件中除了有类的版本、字段、方法等描述等信息外；还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分将在类加载后存放到元空间的运行时常量池中</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">使用元空间代替永久代原因</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">永久代的大小是在启动时固定好的，很难进行调优；太大则容易导致永久代溢出；太小在运行时，容易抛出OutOfMemeryError</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">字符串存在永久代中，使用时易出问题，由于永久代内存经常不够用，爆出异常OutOfMemoryError: PermGen</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">CodeCache</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JVM生成的native code存放的内存空间称之为Code Cache；JIT编译、JNI等都会编译代码到native code，其中JIT生成的native code占用了Code Cache的绝大部分空间</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">直接内存
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">它并不是虚拟机运行时数据区的一般分，也不在规范定义。JDK1.4，引入了Channel(通道)与Buffer(缓存区)的I/O方式，它可以使用Native函数分配堆外内存，可通过DirectByteBuffer操作。</section></li></ul>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">3 JVM运行时内存布局和JMM内存模型区别</span><span class="suffix"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcf4c7b7bf4c413ab353aa01808c79f8~tplv-k3u1fbpfcp-zoom-1.image" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JVM内存区域是指JVM运行时将内存数据分区域存储，强调对内存空间的划分</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JAVA内存模型是Java语言在多线程并发情况下对于共享变量内存操作的规范：解决变量在多线程的可见性、原子性的问题</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">4 JMM内存模型交互操作</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">内存交互操作有八种，虚拟机的实现保证每一个操作都是原子性的</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">lock(锁定)：作用于主内存的变量，标识变量为线程独占状态</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">unlock(解锁)：作用于主内存的变量，释放一个处于锁定状态的变量，释放后的变量才可以被其他线程锁定</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">read(读取)：作用于主内存变量，从主内存中读取出后面load操作要用到的变量</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">load(载入)：作用于主内存中的变量，把刚才read的值放入工作内存的副本中</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">use(使用)：作用于工作内存中的变量，当线程执行某个字节码指令需要用到相应的变量时，把工作内存中的变量副本传给执行引擎</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">assign(赋值)：作用于工作内存中的变量，把一个从执行引擎中接受到的值放入工作内存的变量副本中</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">store(存储)：作用于工作内存中的变量，把工作内存中的变量送到主内存，给后续的write使用</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">write(写入)：作用于主内存中的变量，把store的工作内存中的变量值，写入主内存中</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">read和load 好像是相同的操作？各位有何高见，请指教下</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">JMM对这八种指令的使用，制定了如下规则</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">read和load、store和write必须顺序执行，而且两个指令绑定出现；就是说出现read就要有load</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不允许一个线程丢弃最近的assign操作，工作内存中的变量改变后，必须write同步到主内存</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不允许一个线程把没有发生assign操作的变量同步到主内存</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">新的变量必须诞生于主内存，不允许工作内存使用一个没有初始化的变量；use、store操作变量之前，必须经过load和assign操作</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">变量同一时刻只允许一个线程对其lock，该线程可以对该变量加锁多次，释放锁需要执行相同次数的unlock，lock和unlock要成对出现</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一个变量没有lock，不能unlock；并且一个线程不能unlock被其他线程锁住的变量</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">执行unlock前，必须把工作内存中的变量同步到主内存中</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">执行lock操作，需要清空工作内存（所有），并且需要使用该变量之前，要重新执行load和assign操作</section></li></ul>
</section></li></ul>
<hr data-tool="mdnice编辑器" style="height: 1px; margin-top: 10px; margin-bottom: 10px; border: none; border-top: 1px solid black; margin: 20px 0;">
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 22px; color: #009688; padding-left: 10px; margin: 1em auto; border-left: 3px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">欢迎指正文中错误</span><span class="suffix"></span></h2>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">关注公众号，一起交流</span><span class="suffix"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367b94da0e9fd2?w=1013&amp;h=451&amp;f=png&amp;s=212256" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">参考文章</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">深入理解Java虚拟机</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><span class="footnote-word" style="font-weight: bold; color: #009688;">JVM之内存布局超详细整理</span><sup class="footnote-ref" style="line-height: 0; font-weight: bold; color: #009688;">[1]</sup></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><span class="footnote-word" style="font-weight: bold; color: #009688;">Metaspace 之一：Metaspace整体介绍</span><sup class="footnote-ref" style="line-height: 0; font-weight: bold; color: #009688;">[2]</sup></section></li></ul>
<h3 class="footnotes-sep" data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px; margin: 0.6em auto; padding-left: 10px; border-left: 2px solid #009688;"><span style="display: block;">参考资料</span></h3>
<section class="footnotes" data-tool="mdnice编辑器">
<span id="fn1" class="footnote-item" style="display: flex;"><span class="footnote-num" style="display: inline; width: 10%; background: none; font-size: 80%; opacity: 0.6; line-height: 26px; font-family: ptima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;">[1] </span><p style="padding-top: 8px; padding-bottom: 8px; text-align: justify; display: inline; font-size: 14px; width: 90%; padding: 0px; margin: 0; line-height: 26px; color: black; word-break: break-all; width: calc(100%-50);">JVM之内存布局超详细整理: <em style="font-style: italic; color: black;">https://blog.csdn.net/mayfly_hml/article/details/102805030</em></p>
</span>
<span id="fn2" class="footnote-item" style="display: flex;"><span class="footnote-num" style="display: inline; width: 10%; background: none; font-size: 80%; opacity: 0.6; line-height: 26px; font-family: ptima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;">[2] </span><p style="padding-top: 8px; padding-bottom: 8px; text-align: justify; display: inline; font-size: 14px; width: 90%; padding: 0px; margin: 0; line-height: 26px; color: black; word-break: break-all; width: calc(100%-50);">Metaspace 之一：Metaspace整体介绍: <em style="font-style: italic; color: black;">https://www.cnblogs.com/duanxz/p/3520829.html</em></p>
</span>
</section>
</section>