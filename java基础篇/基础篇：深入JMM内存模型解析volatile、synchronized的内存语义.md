<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"><h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">1 java内存模型，JMM(JAVA Memory Model)</span><span class="suffix"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzEzLzE3MzQ2OTdiM2E5ZDg5Yzg?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">1.1</strong> 线程A需要和线程B交互，则需要更新工作内存的共享变量副本到主存，然后线程B去主存读取更新后的变量</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">1.2</strong> java线程之间的通信是由JMM控制的，JMM决定线程对共享变量的写入何时对另一线程可见。共享变量存在主存，线程拥有自己的工作内存(一个抽象的概念，它覆盖了缓存，写缓冲区，寄存器等)</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">2 CPU高速缓存、MESI协议</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">处理器的高速发展，CPU的性能和内存性能差距拉大，为了解决问题，CPU设置多级缓存，例如L1、L2、L3高速缓存(Cache)。</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;"><strong style="font-weight: bold; color: black;">和JMM的内存布局相似，前者是系统级别，解决缓存一致性问题；后者是应用级别的，解决的是内存一致性问题</strong></p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">这些高速缓存一般都是独属于CPU内部的，对其他CPU不可见，此时又会出现缓存和主存的数据不一致现象，CPU的解决方案有两种</p>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">总线锁定：当某个CPU处理数据时，通过锁定系统总线或者是内存总线，让其他CPU不具备访问内存的访问权限，从而保证了缓存的一致性</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">缓存一致性协议(<strong style="font-weight: bold; color: black;">MESI</strong>)：<font color="red">缓存一致性协议也叫缓存锁定，缓存一致性协议会阻止两个以上CPU同时修改映射相同主存数据的缓存副本</font></section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">MESI实现是依靠处理器使用<strong style="font-weight: bold; color: black;">嗅探技术</strong>保证它的内部缓存、系统主内存和其他处理器的缓存的数据在总线上保持一致</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">例：处理器打算回写脏内存地址，而此内存处于共享状态(Share)；那么其他处理器会嗅探到，并将使自身的对应的缓存行无效，在下次访问相应内存地址时，刷新该缓存行</p>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">缓存数据状态有如下四种(MESI):</p>
<section class="table-container" style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500; overflow-x: auto;"><table style="display: table; text-align: left;">
<thead>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<th style="font-size: 16px; padding: 5px 10px; text-align: left; font-weight: bold; border: 1px solid #009688; background-color: #009688; color: #f8f8f8; border-bottom: 0; min-width: 85px;">缓存状态</th>
<th style="font-size: 16px; padding: 5px 10px; text-align: left; font-weight: bold; border: 1px solid #009688; background-color: #009688; color: #f8f8f8; border-bottom: 0; min-width: 85px;">描述</th>
</tr>
</thead>
<tbody style="border: 0;">
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">M(Modifed)</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">在缓存行中被标记为Modified的值，与主存的值不同，这个值将会在它被其他CPU读取之前写入内存，并设置为Shared</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #f8f8f8;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">E(Exclusive)</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">该缓存行对应的主存内容只被该CPU缓存，值和主存一致，被其他CPU读取时置为Shared，被其他CPU写时置为Modified</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">S(Share)</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">该值也可能存在其他CPU缓存中，但是它的值和主存一致</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #f8f8f8;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">I(Invalid)</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">该缓存行数据无效，需要时需重新从主存载入</td>
</tr>
</tbody>
</table>
</section></section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">3 指令重排序和内存屏障指令</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">为提高程序性能，编译器和处理器经常会对指令做重排序，分别是<strong style="font-weight: bold; color: black;">编译器优化的重排序</strong>、<strong style="font-weight: bold; color: black;">指令并行级别的重排序</strong>，<strong style="font-weight: bold; color: black;">内存系统的重排序</strong>。
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzEzLzE3MzQ3NzUzNzYwYmY3ZjU?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">指令并行重排序和内存系统重排序归为处理器重排序</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">编译器级优化重排序，可由JMM规则禁止<strong style="font-weight: bold; color: black;">特定类型</strong>的指令重排；对于处理器级别重排序则是插入特定类型的<strong style="font-weight: bold; color: black;">内存屏障指令</strong>，以此禁止特定类型的重排序</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CPU的设计者提供内存屏障机制，是将对共享变量读写的<strong style="font-weight: bold; color: black;">高速缓存的强一致性控制权</strong>(MESI的机制)交给了程序员或编译器</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这里介绍两种处理器级别的<strong style="font-weight: bold; color: black;">内存屏障指令</strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">写内存屏障：该屏障之前的写操作先于之后的写操作；在指令后插入StoreBarrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">读内存屏障：该屏障之前的读操作先于之后的读操作；在指令前插入LoadBarrier，让高速缓存中的数据失效，强制从主内存加载数据</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">内存屏障有两个作用：<font color="red"><strong style="font-weight: bold; color: black;">阻止屏障两侧的指令重排序</strong>；<strong style="font-weight: bold; color: black;">强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效</strong></font></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JAVA的<strong style="font-weight: bold; color: black;">内存屏障指令</strong>，基本可以理解为在CPU内存屏障指令上二次封装</section></li></ul>
<section class="table-container" data-tool="mdnice编辑器" style="overflow-x: auto;"><table style="display: table; text-align: left;">
<thead>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<th style="font-size: 16px; padding: 5px 10px; text-align: left; font-weight: bold; border: 1px solid #009688; background-color: #009688; color: #f8f8f8; border-bottom: 0; min-width: 85px;">JAVA内存屏障指令</th>
<th style="font-size: 16px; padding: 5px 10px; text-align: left; font-weight: bold; border: 1px solid #009688; background-color: #009688; color: #f8f8f8; border-bottom: 0; min-width: 85px;">作用描述</th>
</tr>
</thead>
<tbody style="border: 0;">
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">Store1;StoreStore;Store2</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">确保Store1数据对其他处理器可见(<strong style="font-weight: bold; color: black;">刷新到内存</strong>)，先于Store2及所有后续存储指令的存储。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #f8f8f8;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">Load1;LoadStore;Store2</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">确保Load1数据装载先于Store2及所有后续存储指令的存储。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">Store1;StoreLoad;Load2</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">确保Store1数据对其他处理器可见(<strong style="font-weight: bold; color: black;">刷新到内存</strong>)先于Load2及所有后续装载指令的装载。</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #f8f8f8;">
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">Load1;LoadLoad;Load2</td>
<td style="font-size: 16px; padding: 5px 10px; text-align: left; border: 1px solid #009688; min-width: 85px;">确保Load1数据的装载，先于Load2及所有后续装载指令的装载。</td>
</tr>
</tbody>
</table>
</section><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">特殊的是StoreLoad，会使该屏障之前的所有内存访问指令(装载和存储指令)完成之后，才执行该屏障之后的内存访问指令；是一个”全能型”的屏障，它同时具有其他三个屏障的效果</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">用一句话描述java内存屏障的目的：<font color="red"><strong style="font-weight: bold; color: black;">把当前工作内存的数据全部刷新到主内存，并且其他工作内存的共享变量全部失效，真正需要用时再读取主存最新的值</strong></font></section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">4 happen-before原则</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">内存屏障是相对于jvm，cpu级别的内存一致性(内存可见性)的解决方案；为了让java程序员更容易理解，jsr-133使用happens-before的概念来说明不同操作之间的内存可见性
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">程序次序规则：同一个线程，任意一操作happens-before同线程之后的全部操作</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">监视器锁(synchronized)规则</strong>：对一个监视器锁的解锁，happens-before随后对这个锁的加锁</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">volatile变量规则</strong>：对volatile变量的写操作，happens-before该volatile变量之后的任意读操作</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">传递性：如果A先于B；B先于C；则A先于C</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">happens-before部分规则是基于内存屏障实现的</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">5 synchronized内存语义</span><span class="suffix"></span></h1>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span>&nbsp;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">Count</span></span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>&nbsp;a&nbsp;=&nbsp;<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">synchronized</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span>&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">writer</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span></span>{<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;1&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a++;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//2</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//3</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">synchronized</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span>&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">reader</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span></span>{<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;4&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>&nbsp;i&nbsp;=&nbsp;a;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//5&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//6</span><br>}<br></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">根据程序次序规则，1 happens-before 2，2 happens-before 3；4 happens-before 5，5 happens- before 6。 根据监视器锁规则，3 happens-before 4。根据happens-before的传递性得 2 happens-before 5。执行结果如下图</section></li></ul>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkNGZhNjdiNDRiYjM?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">线程释放锁时内存语义：<font color="red">JMM会把该线程对应的工作内存中的共享变量刷新到主内存中</font></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">线程获取锁时内存语义：<font color="red">JMM会把该线程对应的工作内存置为无效</font></strong></section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">6 volatile的内存语义</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">volatile变量具有<strong style="font-weight: bold; color: black;">可见性</strong>，Java线程内存模型确保所有线程看到这个变量的值是最新的，并且单个volatile变量的读/写具有原子性；java编译器对volatile变量处理如下
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在每个volatile写操作的前面插入一个StoreStore屏障</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在每个volatile写操作的后面插入一个StoreLoad屏障</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在每个volatile读操作的后面插入一个LoadLoad屏障</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在每个volatile读操作的后面插入一个LoadStore屏障</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">注意i++是复合操作，即使 i 是volatile变量，也不保证i++是原子操作</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">volatile</span>&nbsp;Object&nbsp;instance;<br>instance&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span>&nbsp;Object();<br><span class="hljs-comment" style="color: #007400; line-height: 26px;">//相应汇编代码</span><br><span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0x01a3de1d</span>:&nbsp;movb&nbsp;$<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>×<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>,<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>×<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1104800</span>(%esi);<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0x01a3de24</span>:&nbsp;lock&nbsp;addl&nbsp;$<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>×<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>,(%esp);<br></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当volatile变量修饰的共享变量进行写操作的反汇编代码会出现<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">0x01a3de24: lock addl $0×0,(%esp)</code>，其实就是插入了内存屏障导致的结果，lock表示volatile变量写时被缓存锁定了(MESI协议)，作用如下
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">禁止指令重排序</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">将当前处理器缓存行的数据写回到系统内存</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</section></li></ul>
</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>&nbsp;a&nbsp;=&nbsp;<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">volatile</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">boolean</span>&nbsp;v&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">false</span>;<br><br>线程A<br>a&nbsp;=&nbsp;<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//1&nbsp;</span><br>v&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">true</span>;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//2</span><br><br>线程B<br>v&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">true</span>;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//3</span><br>System.out.println(a);<span class="hljs-comment" style="color: #007400; line-height: 26px;">//4&nbsp;&nbsp;</span><br></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">根据程序次序规则，1 happens-before 2;3 happens-before 4。根据volatile变量规则，2 happens-before 3。 根据happens-before的传递性规则，1 happens-before 4。程序的执行结果表现如下图</section></li></ul>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzEzLzE3MzQ4OTc4MDI1YjJmN2Q?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">volatile写的内存语义：<font color="red">写volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</font></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">volatile读的内存语义：<font color="red">读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量</font></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">非基本字段不应该用volatile修饰。其原因是volatile修饰对象或数组时，只能保证他们的引用地址的可见性</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">7 final内存语义</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">final写内存语义：
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><font color="red">在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。保障对象被引用之前，fianl域里的变量都是被初始化的</font></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">实现原理：编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: -webkit-box; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span>&nbsp;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">Example</span>&nbsp;</span>{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>&nbsp;i;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//普通类型</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>&nbsp;j;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;引用类型&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">Example</span>&nbsp;<span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>&nbsp;</span>{&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;构造函数&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>;&nbsp;&nbsp;j&nbsp;=&nbsp;<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span>&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">writer</span>&nbsp;<span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>&nbsp;</span>{&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;写线程A执行&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span>&nbsp;Example&nbsp;();&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span>&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">reader</span>&nbsp;<span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>&nbsp;</span>{&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;读线程B执行&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example&nbsp;object&nbsp;=&nbsp;obj;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;读对象引用&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>&nbsp;a&nbsp;=&nbsp;object.i;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;读普通域&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>&nbsp;b&nbsp;=&nbsp;object.j;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;读final域&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">final只会禁止对其修饰变量的写操作，被重排序到构造函数之外；普通变量 i 的赋值可能会被重排到序构造函数之外</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">A线程创建obj，可能让线程B拿到初始化一半的obj；final变量 j 被初始化，而普通变量 i 还没初始化</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">疑问：<font color="red">内存屏障不是会禁止指令重排吗？</font>个人猜想应该是编译器先重排序，此时普通变量已经在构造器外了，再根据final类型插入内存屏障。上面的代码执行可能有如下情况：
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkNzkzNmQ0ZTE1ZWM?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">final读内存语义
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><font color="red">初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序</font></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">实现原理：要求编译器在读final域的操作前面插入一个LoadLoad屏障</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">当使用final修饰引用对象或者数组时，final只保证在构造器返回之前对引用对象的操作先于构造器返回之后的操作<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: -webkit-box; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span>&nbsp;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">Example</span>&nbsp;</span>{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>[]&nbsp;intArray;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;intArray&nbsp;是引用类型&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">Example</span>&nbsp;<span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>&nbsp;</span>{&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;构造函数&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intArray&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span>[<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>];&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intArray[<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>]&nbsp;=&nbsp;<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//此操作对获取该对象引用的线程是可见的</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></pre>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">8 synchronized,volatile内存语义的原理梳理</span><span class="suffix"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE1LzE3MzUwODViNjA2M2Q0NGY?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">9 应用题：延迟加载双重锁定是否真的安全</span><span class="suffix"></span></h1>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span>&nbsp;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">Instance</span>&nbsp;</span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;1</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">private</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;Instance&nbsp;instance;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;2</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;Instance&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">getInstance</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>&nbsp;</span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;3</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span>&nbsp;(instance&nbsp;==&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">null</span>)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;4:第一次检查</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">synchronized</span>&nbsp;(Instance.class)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;5:加锁</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span>&nbsp;(instance&nbsp;==&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">null</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;6:第二次检查</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span>&nbsp;Instance();&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;7:问题的根源出在这里</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;8</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;9</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span>&nbsp;instance;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;10</span><br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;11</span><br>}<br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">代码第7行<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">instance=new Singleton();</code>创建了一个对象。这一行代码可以分解为如下的3行伪代码</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;">memory&nbsp;=&nbsp;allocate();&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;A1：分配对象的内存空间&nbsp;</span><br>ctorInstance(memory);&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;A2：初始化对象&nbsp;</span><br>instance&nbsp;=&nbsp;memory;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;A3：设置instance指向刚分配的内存地址</span><br></code></pre>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; text-align: justify;">假如2和3之间重排序之后的顺序如下</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #fff; border-radius: 5px;">memory&nbsp;=&nbsp;allocate();&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;A1：分配对象的内存空间&nbsp;</span><br>instance&nbsp;=&nbsp;memory;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//A3：instance指向刚分配的内存地址，此时对象还没有被初始化</span><br>ctorInstance(memory);&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;A2：初始化对象</span><br></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">假如发生A3、A2重排序，线程是不保障<strong style="font-weight: bold; color: black;">赋值</strong>和<strong style="font-weight: bold; color: black;">初始化对象</strong>两步骤操作结果会一起同步到主存</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><font color="red">因此第二个线程执行到<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">if (instance == null);// 4:第一次检查</code>时，可能会得到一个刚分配的内存而没初始化的对象(此时没有加锁，锁的happens-before规则不适用)</font></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">相应的两个解决方法
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">在锁内使用volatile修饰instance，volatile保障指令禁止重排序，并且保障变量的内存可见性：<code style="font-size: 14px; word-wrap: break-word; padding: 2px 4px; border-radius: 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688;">private volatile static Instance instance;</code></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使用类加载器的全局锁，在执行类的初始化期间，JVM会去获取一个锁；这个锁可以同步多个线程对同一个类的初始化，每个线程都会试图获取该类的全局锁去初始化类</section></li></ul>
<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: -webkit-box; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span>&nbsp;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">InstanceFactory</span>&nbsp;</span>{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">private</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;<span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span>&nbsp;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">InstanceHolder</span>&nbsp;</span>{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;Instance&nbsp;instance&nbsp;=&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span>&nbsp;Instance();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;Instance&nbsp;<span class="hljs-title" style="color: #1c00cf; line-height: 26px;">getInstance</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;这里将导致InstanceHolder类被初始化&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span>&nbsp;InstanceHolder.instance&nbsp;;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<br>}<br></code></pre>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">10 题外话：伪共享(false sharing)</span><span class="suffix"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">伪共享
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">前面介绍到每个CPU都有属于自己的高速缓存，但是缓存数据大小是怎样的呢？</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">这个大小并不是我们需求存多大就存多大的，而是一个固定的大小-64字节，缓存的加载更新都是以连续的64字节内存为单位，称之为缓存行</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">一缓存行是可以存在多个变量的，比如long类型(64位==8字节)，可以存入8个</section></li></ul>
</section></li></ul>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRkNzVhMjIxYzZhMzg?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><font color="red">假如变量A和变量B是在同一连续的内存，CPU缓存加载A时，B也会被读取；反之亦然，A的脏回写导致在其他CPU相应内存失效的同时，同一缓存行的B内存也被标识为Modified(同舟共渡，一起翻船)</font></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">设想变量A和B没有关联，却刚好在同一缓存行；然后A被CPU-X处理，B被CPU-Y处理；因为CPU-X对A的缓存更新而导致B的缓存失效；CPU-Y要处理B，则要读取更新后的缓存行(B实际是没被更新)，造成没必要的内存读取开销。这就是<strong style="font-weight: bold; color: black;">伪共享</strong></section></li></ul>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE0LzE3MzRjYWRkMDI4ZjI1MTY?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">伪共享的解决方法：
<br> 1- 填充字节，将对应的变量填充到缓存行的大小。如下面定义的类，声明额外的属性<pre class="custom" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://my-wechat.mdnice.com/point.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; display: -webkit-box; -webkit-overflow-scrolling: touch; font-size: 14px; word-wrap: break-word; padding: 2px 4px; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #009688; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span>&nbsp;<span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span>&nbsp;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">FilledLong</span>&nbsp;</span>{<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">/**value&nbsp;加&nbsp;p1&nbsp;-&nbsp;p6；加对象头8个字节正好等于一缓存行的大小&nbsp;*/</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//markWord&nbsp;+&nbsp;klass&nbsp;(32位机,64位是16字节)&nbsp;8字节&nbsp;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">volatile</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">long</span>&nbsp;value&nbsp;=&nbsp;<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0L</span>;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//&nbsp;8字节</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span>&nbsp;<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">long</span>&nbsp;p1,&nbsp;p2,&nbsp;p3,&nbsp;p4,&nbsp;p5,&nbsp;p6;&nbsp;<span class="hljs-comment" style="color: #007400; line-height: 26px;">//48字节</span><br>}<br></code></pre>
2- 使用jdk的注解@Contended修饰变量，jvm会自动将变量填充到缓存行的大小。注意的是需要加入启动参数 -XX:-RestrictContended</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; font-size: 1.8em; color: #009688; margin: 1.2em auto; text-align: center; border-bottom: 1px solid #009688;"><span class="prefix" style="display: none;"></span><span class="content">关注公众号，一起交流</span><span class="suffix"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC83LzE5LzE3MzY3Yjk0ZGEwZTlmZDI?x-oss-process=image/format,png" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure>
</section>