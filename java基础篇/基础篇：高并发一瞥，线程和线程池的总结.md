<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; padding: 0 10px; word-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; line-height: 1.25; color: #2b2b2b; font-family: Optima-Regular, Optima, PingFangTC-Light, PingFangSC-light, PingFangTC-light; letter-spacing: 2px; background-image: linear-gradient(90deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.04) 3%, rgba(0, 0, 0, 0) 3%); background-size: 20px 20px; background-position: center center;"><h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">1 JAVA线程的实现原理</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384df5977c06a1?w=641&amp;h=540&amp;f=png&amp;s=36079" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">java的线程是基于操作系统原生的线程模型(非用户态)，通过系统调用，将程序的线程交给系统调度执行</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">java线程拥有属于自己的虚拟机栈，当JVM将栈、程序计数器、工作内存等准备好后，会分配一个系统原生线程来执行。Java线程结束，原生线程随之被回收</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">原生线程初始化完毕，会调Java线程的run方法。当JAVA线程结束时，则释放原生线程和Java线程的所有资源</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">java方法的执行对应虚拟机栈的一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">2 JAVA线程的生命周期</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;"><img src="https://user-gold-cdn.xitu.io/2020/7/25/17384f406b1ad13c?w=508&amp;h=376&amp;f=png&amp;s=34993" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;">
<img src="https://user-gold-cdn.xitu.io/2020/7/27/1738ea81d5bac936?w=963&h=528&f=png&s=92140" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">New(新建状态)：用new关键字创建线程之后，该线程处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">Runnable(就绪状态)：当调用Thread.start方法后，该线程处于就绪状态。JVM会为其分配虚拟机栈等，然后等待系统调度</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">running(运行状态)：处于就绪状态的线程获得CPU，执行run方法时，则线程处于运行状态</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">Terminated(线程死亡)：线程正常run结束、或抛出一个未捕获的Throwable、调用Thread.stop来结束该线程，都会导致线程的死亡</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">3 JAVA线程的几种常用方法</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>线程启动函数<span>」</span></strong></section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Thread.java</span>
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//调用start启动线程，进入Runnable状态，等待系统调度执行</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">synchronized</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">start</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span></span>{<span class="hljs-comment" style="color: #007400; line-height: 26px;">//synchronized同步执行</span>
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (threadStatus != <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>) <span class="hljs-comment" style="color: #007400; line-height: 26px;">//0 代表new状态，非0则抛出错误</span>
<span/>            <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">throw</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> IllegalThreadStateException();
<span/>    ...
<span/>    start0(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//本地方法方法 private native void start0()</span>
<span/>    ...
<span/>}
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Running状态，新线程执行的代码方法，可被子类重写</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">run</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span> </span>{
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (target != <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">null</span>) {
<span/>        <span class="hljs-comment" style="color: #007400; line-height: 26px;">//target是Runnable,new Thread(Runnable)时传入</span>
<span/>        target.run(); 
<span/>    }
<span/>}
<span/>
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>线程终止函数<span>」</span></strong></section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Thread.java</span>
<span/><span class="hljs-meta" style="color: #643820; line-height: 26px;">@Deprecated</span> <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">stop</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span></span>;
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//中断线程</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">interrupt</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//判断的是当前线程是否处于中断状态</span>
<span/><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">boolean</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">interrupted</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span>
<span/></span></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">用stop会强行终止线程，导致线程所持有的全部锁突然释放(不可控制)，而被锁突同步的逻辑遭到破坏。不建议使用</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">interrupt函数中断线程，但它不一定会让线程退出的。它比stop函数优雅，可控制
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">当线程处于调用sleep、wait的阻塞状态时，会抛出InterruptedException，代码内部捕获，然后结束线程</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">线程处于非阻塞状态，则需要程序自己调用interrupted()判断，再决定是否退出</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">其他常用方法</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Thread.java</span>
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//阻塞等待其他线程</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">synchronized</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">join</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">long</span> millis)</span>
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//暂时让出CPU执行</span>
<span/><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">native</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">yield</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span></span>;
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//休眠一段时间</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">native</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">sleep</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">long</span> millis)</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">throws</span> InterruptedException</span>;
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">start与run方法的区别
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">start是Thread类的方法，从线程的生命周期来看，start的执行并不意味着新线程的执行，而是让JVM分配虚拟机栈，进入Runnable状态，start的执行还是在旧线程上</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">run则是新线程被系统调度，获取CPU时，执行的方法，必须是继承Thread或者是实现Runnable接口</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">Thread.sleep与Object.wait区别
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">Thread.sleep需要指定休眠时间，时间一到继续运行；和锁机制无关，不能加锁也不用释放锁</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">Object.wait需要在synchronized中调用，否则报IllegalMonitorStateException错误。wait方法会释放锁，需要调用相同锁对象Object.notify来唤醒线程</section></li></ul>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">4 线程池及其优点</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">线程的每次使用时创建，结束再销毁，是非常巨大的开销。若用缓存的策略(线程池)，暂存曾经创建的线程，复用这些线程，可以减少程序的消耗，提高线程的利用率</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">降低资源消耗：重复利用线程可降低线程创建和销毁造成的消耗</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">提高响应速度：当任务到达时，不需要等待线程创建就能立即执行</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">提高线程的可管理性：使用线程池可以进行统一的分配，监控和调优</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">5 JDK封装的线程池</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/26/1738953b0d5ac72e?w=630&amp;h=414&amp;f=png&amp;s=17136" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//ThreadPoolExecutor.java</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">ThreadPoolExecutor</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> corePoolSize, 
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> maximumPoolSize,
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">long</span> keepAliveTime,
<span/>    TimeUnit unit,
<span/>    BlockingQueue&lt;Runnable&gt; workQueue,
<span/>    ThreadFactory threadFactory,
<span/>    RejectedExecutionHandler handler)</span> 
<span/></span></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">1 corePoolSize：核心线程数，线程池维持的线程数量</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">2 maximumPoolSize：最大的线程数，当阻塞队列不可再接受任务时且maximumPoolSize大于corePoolSize则会创建非核心线程来执行。无任务执行时，会被销毁</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">3 keepAliveTime：非核心线程在闲暇间的存活时间</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">4 TimeUnit：和keepAliveTime配合使用，表示keepAliveTime参数的时间单位</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">5 workQueue：正在执行的任务数超过corePoolSize时，任务的等待阻塞队列</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">6 threadFactory：线程的创建工厂</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">7 handler：拒绝策略，线程数达到了maximumPoolSize，还有任务提交则使用拒绝策略处理</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">6 线程池原理之执行流程</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/25/1738539c638224c9?w=715&amp;h=502&amp;f=png&amp;s=72158" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//ThreadPoolExecutor.java</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">execute</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(Runnable command)</span> </span>{
<span/>    ...
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (workerCountOf(c) &lt; corePoolSize) { <span class="hljs-comment" style="color: #007400; line-height: 26px;">//plan A</span>
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (addWorker(command, <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">true</span>))  
<span/>            <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span>;
<span/>        c = ctl.get();
<span/>    }
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) { <span class="hljs-comment" style="color: #007400; line-height: 26px;">//plan B</span>
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> recheck = ctl.get();
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (! isRunning(recheck) &amp;&amp; remove(command))
<span/>            reject(command);
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">else</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (workerCountOf(recheck) == <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>)
<span/>            addWorker(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">null</span>, <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">false</span>);
<span/>    }
<span/>    <span class="hljs-comment" style="color: #007400; line-height: 26px;">//addWorker(command, false) false代表可创建非核心线程执行任务</span>
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">else</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (!addWorker(command, <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">false</span>)) <span class="hljs-comment" style="color: #007400; line-height: 26px;">//plan C</span>
<span/>        reject(command);    <span class="hljs-comment" style="color: #007400; line-height: 26px;">// //plan D</span>
<span/>}
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">plan A：任务的execute，先判断核心线程数量达到上限；否，则创建核心线程来执行任务；是，则执行plan B</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">plan B：当任务数大于核心数时，任务被加入阻塞队列，如果超过阻塞队列的容量上限，执行C</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">plan C: 阻塞队列不能接受任务时，且设置的maximumPoolSize大于corePoolSize，创建新的非核心线程执行任务</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">plan D：当plan A、B、C都无能为力时，使用拒绝策略处理</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">7 阻塞队列的简单了解</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">队列的阻塞插入：当队列满时，队列会阻塞插入元素的线程，直到队列不满</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">队列的阻塞移除：当队列为空时，获取元素的线程会等待队列变为非空</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">BlockingQueue提供的方法如下，其中put和take是阻塞操作</section></li></ul>
<section class="table-container" data-tool="mdnice编辑器" style="overflow-x: auto;"><table style="display: table; text-align: left;">
<thead>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959; min-width: 85px;">操作方法</th>
<th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959; min-width: 85px;">抛出异常</th>
<th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959; min-width: 85px;">阻塞线程</th>
<th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959; min-width: 85px;">返回特殊值</th>
<th style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-weight: bold; background-color: #f0f0f0; font-size: 14px; color: #595959; min-width: 85px;">超时退出</th>
</tr>
</thead>
<tbody style="border: 0;">
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">插入元素</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">add(e)</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">put(e)</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">offer(e)</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">offer(e, timeout, unit)</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: #F8F8F8;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">移除元素</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">remove()</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">take()</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">poll()</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">pull(timeout, unit)</td>
</tr>
<tr style="border: 0; border-top: 1px solid #ccc; background-color: white;">
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">检查</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">element()</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">peek()</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">无</td>
<td style="border: 1px solid #ccc; padding: 5px 10px; text-align: left; font-size: 14px; color: #595959; min-width: 85px;">无</td>
</tr>
</tbody>
</table>
</section><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>ArrayBlockingQueue<span>」</span></strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">ArrayBlockingQueue是用数组实现的<strong style="color: #3594F7; font-weight: bold;"><span>「</span>有界阻塞队列<span>」</span></strong>，必须指定队列大小，先进先出(FIFO)原则排队</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>LinkedBlockingQueue<span>」</span></strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">是用链表实现的<strong style="color: #3594F7; font-weight: bold;"><span>「</span>有界阻塞队列<span>」</span></strong>，如果构造LinkedBlockingQueue时没有指定大小，则默认是Integer.MAX_VALUE，无限大</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">该队列生产端和消费端使用独立的锁来控制数据操作，以此来提高队列的并发性</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>PriorityBlockingQueue<span>」</span></strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><code style="font-size: 14px; word-wrap: break-word; margin: 0 2px; background-color: rgba(27,31,35,.05); font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; word-break: break-all; color: #3594F7; background: RGBA(59, 170, 250, .1); padding: 0 2px; border-radius: 2px; height: 21px; line-height: 22px;">public PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">基于数组，元素具有优先级的<strong style="color: #3594F7; font-weight: bold;"><span>「</span>无界阻塞队列<span>」</span></strong>，优先级由Comparator决定</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">PriorityBlockingQueue不会阻塞生产者，却会在没有可消费的任务时，阻塞消费者</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>DelayQueue<span>」</span></strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">支持延时获取元素的<strong style="color: #3594F7; font-weight: bold;"><span>「</span>无界阻塞队列<span>」</span></strong>，基于PriorityQueue实现</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">元素必须实现Delayed接口，指定多久才能从队列中获取该元素。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">可用于缓存系统的设计、定时任务调度等场景的使用</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>SynchronousQueue<span>」</span></strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">SynchronousQueue是一种无缓冲的等待队列，<strong style="color: #3594F7; font-weight: bold;"><span>「</span>添加一个元素必须等待被取走后才能继续添加元素<span>」</span></strong></section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>LinkedTransferQueue<span>」</span></strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">由链表组成的TransferQueue<strong style="color: #3594F7; font-weight: bold;"><span>「</span>无界阻塞队列<span>」</span></strong>，相比其他队列多了tryTransfer和transfer函数</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">transfer：当前有消费者正在等待元素，则直接传给消费者，<strong style="color: #3594F7; font-weight: bold;"><span>「</span>否则存入队尾，并阻塞等待元素被消费才返回<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">tryTransfer：试探传入的元素是否能直接传给消费者。如果没消费者等待消费元素，元素加入队尾，返回false</section></li></ul>
</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>LinkedBlockingDeque<span>」</span></strong>
<ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: square;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">LinkedBlockingDeque是由链表构建的双向阻塞队列，多了一端可操作入队出队，少了一半的竞争，提高并发性</section></li></ul>
</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">8 Executors的四种线程池浅析</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>newFixedThreadPool<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">指定核心线程数，队列是LinkedBlockingQueue无界阻塞队列，永远不可能拒绝任务；适合用在稳定且固定的并发场景，建议线程设置为CPU核数</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Executors.java</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> ExecutorService <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">newFixedThreadPool</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> nThreads)</span> </span>{
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> ThreadPoolExecutor(nThreads, nThreads,
<span/>                        <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0L</span>, TimeUnit.MILLISECONDS,
<span/>                        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> LinkedBlockingQueue&lt;Runnable&gt;());
<span/>}
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>newCachedThreadPool<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">核心池大小为0，线程池最大线程数为最大整型，任务提交先加入到阻塞队列中，非核心线程60s没任务执行则销毁，阻塞队列为SynchronousQueue。newCachedThreadPool会不断的创建新线程来执行任务，不建议用</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Executors.java</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> ExecutorService <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">newCachedThreadPool</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span> </span>{
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> ThreadPoolExecutor(<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>, Integer.MAX_VALUE,
<span/>                  <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">60L</span>, TimeUnit.SECONDS,
<span/>                  <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> SynchronousQueue&lt;Runnable&gt;());
<span/>}
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>newScheduledThreadPool<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">ScheduledThreadPoolExecutor(STPE)其实是ThreadPoolExecutor的子类，可指定核心线程数，队列是STPE的内部类DelayedWorkQueue。<strong style="color: #3594F7; font-weight: bold;"><span>「</span>STPE的好处是 A 延时可执行任务，B 可执行带有返回值的任务<span>」</span></strong></section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Executors.java</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">ScheduledThreadPoolExecutor</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> corePoolSize,
<span/>                                   ThreadFactory threadFactory)</span> </span>{
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">super</span>(corePoolSize, Integer.MAX_VALUE,
<span/>          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,
<span/>          <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> DelayedWorkQueue(), threadFactory);
<span/>}
<span/><span class="hljs-comment" style="color: #007400; line-height: 26px;">//指定延迟执行时间    </span>
<span/><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> &lt;V&gt; <span class="hljs-function" style="line-height: 26px;">ScheduledFuture&lt;V&gt; 
<span/><span class="hljs-title" style="color: #1c00cf; line-height: 26px;">schedule</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(Callable&lt;V&gt; callable, <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">long</span> delay, TimeUnit unit)</span>    
<span/></span></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><strong style="color: #3594F7; font-weight: bold;"><span>「</span>newSingleThreadExecutor<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">和newFixedThreadPool构造方法一致，不过线程数被设置为1了。SingleThreadExecutor比new个线程的好处是；<strong style="color: #3594F7; font-weight: bold;"><span>「</span>线程运行时抛出异常的时候会有新的线程加入线程池完成接下来的任务；阻塞队列可以保证任务按FIFO执行<span>」</span></strong></section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Executors.java</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> ExecutorService <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">newSingleThreadExecutor</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span> </span>{
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> FinalizableDelegatedExecutorService
<span/>        (<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> ThreadPoolExecutor(<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>, <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>,
<span/>                  <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0L</span>, TimeUnit.MILLISECONDS,
<span/>                  <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> LinkedBlockingQueue&lt;Runnable&gt;())); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//无界队列</span>
<span/>}
<span/></code></pre>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">9 如果优雅地关闭线程池</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">线程池的关闭，就要先关闭池中的线程，上文第三点有提，暴力强制性stop线程会导致同步数据的不一致，因此我们要调用interrupt关闭线程</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">而线程池提供了两个关闭方法，shutdownNow和shuwdown</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">shutdownNow：线程池拒接收新任务，同时立马关闭线程池(执行中的会继续执行完)，队列的任务不再执行，返回未执行任务List</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> List&lt;Runnable&gt; <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">shutdownNow</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span> </span>{
<span/>    ...
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span> ReentrantLock mainLock = <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">this</span>.mainLock;
<span/>    mainLock.lock(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//加锁</span>
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">try</span> {
<span/>        checkShutdownAccess();
<span/>        advanceRunState(STOP);
<span/>        interruptWorkers(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//interrupt关闭线程</span>
<span/>        tasks = drainQueue(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//未执行任务</span>
<span/>    ...    
<span/></code></pre>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">shuwdown：线程池拒接收新任务，同时等待线程池里的任务执行完毕后关闭线程池，代码和shutdownNow类似就不贴了</section></li></ul>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">10 线程池为什么使用的是阻塞队列</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">先考虑下为啥线程池的线程不会被释放，它是怎么管理线程的生命周期的呢</p>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//ThreadPoolExecutor.Worker.class</span>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">runWorker</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(Worker w)</span> </span>{
<span/>    ...
<span/>    <span class="hljs-comment" style="color: #007400; line-height: 26px;">//工作线程会进入一个循环获取任务执行的逻辑</span>
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">while</span> (task != <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">null</span> || (task = getTask()) != <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">null</span>)
<span/>    ...
<span/>}
<span/>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">private</span> Runnable <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">getTask</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span></span>{
<span/>    ...
<span/>    Runnable r = timed ? 
<span/>        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) 
<span/>        : workQueue.take(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//线程会阻塞挂起等待任务，</span>
<span/>    ...    
<span/>}
<span/></code></pre>
<p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">可以看出，无任务执行时，线程池其实是利用阻塞队列的take方法挂起，从而维持核心线程的存活</p>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">11 线程池的worker继承AQS的意义</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-comment" style="color: #007400; line-height: 26px;">//Worker class，一个worker一个线程</span>
<span/>Worker(Runnable firstTask) {
<span/>    <span class="hljs-comment" style="color: #007400; line-height: 26px;">//禁止新线程未开始就被中断</span>
<span/>    setState(-<span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>); <span class="hljs-comment" style="color: #007400; line-height: 26px;">// inhibit interrupts until runWorker</span>
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">this</span>.firstTask = firstTask;
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">this</span>);
<span/>}
<span/>
<span/><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">final</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">runWorker</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(Worker w)</span> </span>{
<span/>    ....
<span/>    <span class="hljs-comment" style="color: #007400; line-height: 26px;">//对应构造Worker是的setState(-1)</span>
<span/>    w.unlock(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">// allow interrupts</span>
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">boolean</span> completedAbruptly = <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">true</span>;
<span/>        ....
<span/>        w.lock(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//加锁同步</span>
<span/>        ....
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">try</span> {
<span/>            ...
<span/>            task.run();
<span/>            afterExecute(task, <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">null</span>);
<span/>        } <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">finally</span> {
<span/>            ....
<span/>            w.unlock(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//释放锁</span>
<span/>        }
<span/></code></pre>
<p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">worker继承AQS的意义：A 禁止线程未开始就被中断；B 同步runWorker方法的处理逻辑</p>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">12 拒绝策略</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">AbortPolicy <strong style="color: #3594F7; font-weight: bold;"><span>「</span>丢弃任务并抛出RejectedExecutionException异常<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">DiscardOldestPolicy <strong style="color: #3594F7; font-weight: bold;"><span>「</span>丢弃队列最前面的任务，然后重新提交被拒绝的任务<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">DiscardPolicy <strong style="color: #3594F7; font-weight: bold;"><span>「</span>丢弃任务，但是不抛出异常<span>」</span></strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">CallerRunsPolicy</section></li></ul>
<blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; text-size-adjust: 100%; line-height: 1.55em; font-weight: 400; border-radius: 6px; color: #595959; font-style: normal; text-align: left; box-sizing: inherit; border-left: none; border: 1px solid RGBA(64, 184, 250, .4); background: RGBA(64, 184, 250, .1);"><span style="color: RGBA(64, 184, 250, .5); font-size: 34px; line-height: 1; font-weight: 700;">❝</span>
<p style="padding-top: 8px; padding-bottom: 8px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px; margin: 0px; line-height: 26px; color: #595959;">A handler for rejected tasks that runs the rejected task directly in the calling thread of the {@code execute} method, unless the executor has been shut down, in which case the task is discarded.</p>
<span style="float: right; color: RGBA(64, 184, 250, .5);">❞</span></blockquote>
<p data-tool="mdnice编辑器" style="padding-top: 8px; padding-bottom: 8px; line-height: 26px; color: #2b2b2b; margin: 10px 0px; letter-spacing: 2px; font-size: 14px; word-spacing: 2px;">如果任务被拒绝了，则由<strong style="color: #3594F7; font-weight: bold;"><span>「</span>提交任务的线程<span>」</span></strong>执行此任务</p>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">13 ForkJoinPool了解一波</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/26/17389e7589018b40?w=601&amp;h=386&amp;f=png&amp;s=33832" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">ForkJoinPool和ThreadPoolExecutor不同，它适合执行可以分解子任务的任务，如树的遍历，归并排序等一些递归场景
<img src="https://user-gold-cdn.xitu.io/2020/7/26/17389df09b6f915e?w=667&amp;h=404&amp;f=png&amp;s=44156" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;">
<img src="https://user-gold-cdn.xitu.io/2020/7/26/17389e729b7b9d20?w=627&amp;h=340&amp;f=png&amp;s=36433" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">ForkJoinPool每个线程有一个对应的双端队列deque；当线程中的任务被fork分裂，分裂出来的子任务会放入线程自己的deque，减少线程的竞争</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">work-stealing工作窃取算法
<img src="https://user-gold-cdn.xitu.io/2020/7/26/17389ebdae4e715d?w=762&amp;h=391&amp;f=png&amp;s=43411" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;">
当线程执行完自己deque的任务，且其他线程deque还有多的任务，则会启动窃取策略，从其他线程deque队尾获取线程</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;">使用RecursiveTask实现forkjoin流程demo</section></li></ul>
<pre class="custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #fff; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: black; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; letter-spacing: 0px; padding-top: 15px; background: #fff; border-radius: 5px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span> <span class="hljs-title" style="color: #5c2699; line-height: 26px;">ForkJoinPoolTest</span> </span>{
<span/>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">void</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">main</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(String[] args)</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">throws</span> ExecutionException, InterruptedException </span>{
<span/>        ForkJoinPool forkJoinPool = <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> ForkJoinPool();
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">for</span> (<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> i = <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">0</span>; i &lt; <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">10</span>; i++) {
<span/>            ForkJoinTask task = forkJoinPool.submit(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> Fibonacci(i));
<span/>            System.out.println(task.get());
<span/>        }
<span/>    }
<span/>    <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">static</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">class</span> <span class="hljs-title" style="color: #5c2699; line-height: 26px;">Fibonacci</span> <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">extends</span> <span class="hljs-title" style="color: #5c2699; line-height: 26px;">RecursiveTask</span>&lt;<span class="hljs-title" style="color: #5c2699; line-height: 26px;">Integer</span>&gt; </span>{
<span/>        <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> n;
<span/>        <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">public</span> <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">Fibonacci</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">(<span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">int</span> n)</span> </span>{  <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">this</span>.n = n;  }
<span/>        <span class="hljs-meta" style="color: #643820; line-height: 26px;">@Override</span>
<span/>        <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">protected</span> Integer <span class="hljs-title" style="color: #1c00cf; line-height: 26px;">compute</span><span class="hljs-params" style="color: #5c2699; line-height: 26px;">()</span> </span>{
<span/>            <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">if</span> (n &lt;= <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>) { <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span> n; }
<span/>            Fibonacci fib1 = <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> Fibonacci(n - <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">1</span>);
<span/>            fib1.fork(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//相当于开启新线程执行</span>
<span/>            Fibonacci fib2 = <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">new</span> Fibonacci(n - <span class="hljs-number" style="color: #1c00cf; line-height: 26px;">2</span>);
<span/>            fib2.fork(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//相当于开启新线程执行</span>
<span/>            <span class="hljs-keyword" style="color: #aa0d91; line-height: 26px;">return</span> fib1.join() + fib2.join(); <span class="hljs-comment" style="color: #007400; line-height: 26px;">//合并阻塞返回结果</span>
<span/>        }
<span/>    }
<span/>}
<span/></code></pre>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 22px; display: block; border-bottom: 4px solid #40B8FA;"><span class="prefix" style="display: flex; width: 20px; height: 20px; background-size: 20px 20px; background-image: url(https://imgkr.cn-bj.ufileos.com/15fdfb3c-b350-4da9-928e-5f8c506ec325.png); margin-bottom: -22px;"></span><span class="content" style="display: flex; color: #40B8FA; font-size: 20px; margin-left: 25px;">欢迎指正文中错误</span><span class="suffix" style="display: flex; box-sizing: border-box; width: 200px; height: 10px; border-top-left-radius: 20px; background: RGBA(64, 184, 250, .5); color: rgb(255, 255, 255); font-size: 16px; letter-spacing: 0.544px; justify-content: flex-end; float: right; margin-top: -10px; box-sizing: border-box !important; overflow-wrap: break-word !important;"></span></h2>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">关注公众号，一起交流</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://user-gold-cdn.xitu.io/2020/7/19/17367b94da0e9fd2?w=1013&amp;h=451&amp;f=png&amp;s=212256" alt style="max-width: 100%; border-radius: 6px; display: block; margin: 20px auto; object-fit: contain; box-shadow: 2px 4px 7px #999;"></figure>
<h1 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 25px;"><span class="prefix" style="font-weight: bold; color: #40B8FA; display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; color: #40B8FA;">参考文章</span><span class="suffix" style="display: inline-block; font-weight: bold; color: #40B8FA;"></span></h1>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; font-size: 15px; color: #595959; list-style-type: circle;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><a href="https://www.jianshu.com/p/7c980955627e" style="text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;">Java线程和操作系统线程的关系</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><a href="https://www.cnblogs.com/still-smile/p/11656591.html" style="text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;">线程的3种实现方式</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><a href="https://www.cnblogs.com/qingquanzi/p/9018627.html" style="text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;">如何优雅的关闭Java线程池</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><a href="https://juejin.im/post/6844903882162716685" style="text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;">Java程序员必备的一些流程图</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><a href="https://www.cnblogs.com/frankyou/p/9467905.html" style="text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;">JDK提供的四种线程池</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><a href="https://www.cnblogs.com/youngao/p/12574029.html" style="text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;">7种阻塞队列相关整理</a></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; font-size: 14px; font-weight: normal; color: #595959;"><a href="https://blog.csdn.net/xiewenfeng520/article/details/106943304" style="text-decoration: none; word-wrap: break-word; color: #40B8FA; font-weight: normal; border-bottom: 1px solid #3BAAFA;">六种常见的线程池含ForkJoinPool</a></section></li></ul>
</section>